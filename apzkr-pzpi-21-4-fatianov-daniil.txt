РЕФЕРАТ
Пояснювальна записка до курсової роботи: с. 79, рис. 28, джерела 5
AXIOS, GPS, HTTP, INTELLIJIDEA, JAVA, JSON WEB TOKEN, JWT, 
MONGO, MYSQL, NOSQL, OPENSTREETMAP, OVERPASS API, REACTJS, 
SPRING, SPRING DATA, SPRING FRAMEWORK, SPRING SECURITY, SQL, 
TOKEN, TYPESCRIPT, WEBSTORM, БЕЗПІЛОТНІ АПАРАТИ, БЕЗПІЛОТНІ 
ЗАСОБИ, ДРОНИ, ЗАМОВЛЕННЯ, ЗАПИТИ, КООРДИНАТИ, СТАНЦІЇ, ГЕОДАНІ. 
Метою курсового проєкту є створення програмної системи «програмна
система керування вантажо-переміщенням за допомогою безпілотних апаратів». 
Під час розробки були використані наступні методи дослідження: аналіз 
аналогів, аналіз предметної області, проєктування UML-діаграм, проєктування 
ER-діаграм та моделювання системи.
Для розробки програмної системи використовувались: СУБД PosgreSQL,
NoSQL база даних MongoDB, мови Java та Typescript, фреймворки Spring
Framework, NestJS та ReactJS, середовище розробки IntelliJIDEA Ultimate Edition 
2024 та WebStorm IDE.
Результатом курсового проєкту стала програмна система «програмна
система керування вантажо-переміщенням за допомогою безпілотних апаратів». 
Вона створена для того, щоб надати можливість користувачам робити 
замовлення та доставляти їх за допомогою безпілотних летальний апаратів.

1. Вступ
Давним давно, коли вже було створено колесо, різні вантажі люди 
перевозили за допомогою волів та іншої копитної худоби. Для того часу то було 
дуже гарне рішення, бо дозволяло людям переміщатись на певні відстані разом з 
товаром для продажі на ринку наприклад.
Прогрес не стояв на місці, і через деякий час люди винайшли паровий 
двигун, двигун внутрішнього згорання, двигун зовнішнього згорання, 
електродвигун. На базі цього почали будуватись потяги, машини, мотоцикли, 
кораблі, літаки та багато іншого. Це дозволило значно пришвидшити 
перевезення вантажу з пункту А в пункт Б. Обсяги перевезень сталі більшими, 
люди навість почали возити велику кількість сировини, матеріалів, предметів 
тощо.
В сучасному світі переважно перевезення вантажу на невеликі відносно 
дистанції використовують транспорт. Це займає певний час та коштує доволі 
дорого через ціни на паливо для транспорту. Длі доставок на короткі відстані, 
кур’єри на сьогоднішній день використовують різні види моноколеса, самокати, 
мопеди, велосипеди та навіть автомобілі. Все одно це займає час та потребує 
праці.
Створення системи, яка дозволила б використовувати безпілотні апарати 
для доставки вантажу значно б покращило сферу вантажних перевезень та 
дозволило б облетіти всі пробки та світлофори, що могло б і зменшити час 
доставки. А головне енергія для підзарядки безпілотного апарату коштує 
дешевше, ніж паливо.
Метою даного проєкту є створення програмної системи керування 
вантажо-переміщенням за допомогою безпілотних апаратів, яка дозволить 
покращити сферу перевезень вантажу.

2. Основна частина
2.1. Vision&Scope документ
1. Бізнес-вимоги
2.1.1.1. Передумови

У сучасному світі з’являється багато автоматизованих речей, які працюють 
за заданою програмою, або використовують штучний інтелект. Такі речі, як 
автоматизований склад, пристрої для діставання товару з полиць, розумні камери, 
розумні будинки та інше стають дедалі звичайними речами, до яких вже звикли 
люди. В машинах та БПЛА вже давно використовується автопілот, а недавно до 
цього ще додався штучний інтелект, який з кожним днем стає все розумніше, але 
в деяких областях без людини ще не обійтися.
Послуги з доставки досі використовують людей для перевезення вантажу 
та товарів. Нова пошта використовує транспорт для доставки вантажу на 
відділення, а потім кур'єрів для доставки посилок в поштомати та на дім. Сервіс 
з доставки Glovo також використовує кур’єрів для здійснення перевезень на 
короткі дистанції. Наразі кур’єри використовують транспорт з двигуном, який 
використовує паливо. Це по-перше шкодить навколишньому середовищу, подруге коштує великих грошей, бо ціни на паливо ростуть швидко. Логічніше було 
б використовувати електротранспорт, проте він коштує дорожче, ніж транспорт з 
двигуном та компанії та звичайні кур’єри не готові іти на такі затрати. 
Ще одним виходом з цієї ситуації може слугувати використання керованих 
або автоматизованих БПЛА для доставки вантажу певного розміру та ваги на 
короткі або дальні дистанції. Це значно дешевше аніж бензиновий транспорт та 
іноді швидше, коли наприклад, у місті великі пробки в час пік. Також сучасні 
сервіси з таким типом доставки покривають відносно невеликі території, тому 
використовуються для перевезення вантажу на невеликі відстані.

2.1.1.2. Бізнес-можливості
Ідея створення сервісу перевезення вантажу за допомогою БПЛА не стала 
першою в світі. Amazon створив власний Проєкт безпілотної доставки ще у 2013 
розі, проте через попит та нормативні обмеження Проєкт був закритий. Компанія 
Wing досягла більших успіх та здійснює доставку за допомогою БПЛА на 3 
континентах. 
Wing має власні безпілотники різних розмірів для перевезення замовлень 
їжі або товарів з магазину. Ця компанія відносно недавно стала партнерами з 
Walmart та тепер робить доставку і їх замовлень.
На рисунках Б1 та Б2 можна бачити сам БПЛА компанії та місце посадки, 
яке обладнане QR кодом. Можна зробити висновок, що БПЛА має певний «зір» 
та бачить обстановку навколо себе. Також БПЛА може бути автономним або 
керованим. Керований БПЛА потребує персоналу операторів, для управління, а 
автономний літає за заданою траєкторією або створює її сам, за допомогою 
програми, GPS та аналізу навколишнього середовища. Також необхідно 
зауважити, що всі БПЛА мають максимальну дальність польоту, яка залежить від 
швидкості, завантаження та погодних умов, тому в деякі місця вони долетіти не 
зможуть. 
З мінусів можна виділити можливу крадіжку товару через відсутність точки 
видачі товару користувачу та обмежену відстань польоту.
Також існує компанія Meituan , яка використовує БПЛА для доставки в 
Китаї.
Дрони цієї компанії також мають місця дислокації, обладнані QR кодом, 
який є посадочним місцем БПЛА. Ці дрони невеликі за розміром та доставляють 
лише невеликі за вагою товари. Ця компанія спеціалізується на доставці їжі з 
закладів швидкого харчування. Дрон летить до обраного у додатку «поштомату» 
та залишає там замовлення. Потім цей автомат завантажує коробку в персональну 
комірку, яку можна відчинити за допомогою коду з додатку. 
Ознайомившись з додатком, можна зробити висновок, що користувач 
прямо у додатку обирає заклад або магазин, та робить замовлення товарів. Після 
цього йому необхідно обрати тип замовлення та місце, тому при виборі «доставка 
за допомогою БПЛА» йому необхідно запропонувати найближчий пункт видачі. 
Це дуже зручна можливість.
З мінусів можна виділити обмеження вантажу за розміром та вагою, через 
невеликий розмір дрону, проте це вирішується шляхом його збільшення. 
Дані сервіси з доставки є дуже зручними для отримання переміщення 
невеликого вантажу на невеликі відстані. 
Проаналізувавши дані сервіси доставки можемо зробити такі висновки для 
компанії Wing:
− Зручна та швидка доставка у будь яке місце;
− Великий парк БПЛА;
− Можливість перевезення більшого за розміром та вагою вантажу;
− Розповсюдженість.
Також можна виділити такі плюси сервісу Meituan:
− Швидка доставка у пункти прийому замовлень;
− Захист від крадіїв за допомогою персональних комірок та коду;
− Зручний додаток користувача. 
Можна зробити висновок, що дані сервіси мають великий попит серед 
користувачів та легку можливість зробити замовлення. Сервіс компанії Wing 
інтегрований у системи партнерів, а сервіс компанії Meituan автономний та надає 
можливість зробити замовлення прямо у додатку. Дрони компанії Wing мають 

перевагу перед Meituan через великий парк дронів різного розміру, що дозволяє 
доставляти замовлення більшої ваги та розміру.

2. Концепція рішення
2.1.2.1. Окреслення концепції

Метою проєкту є надання можливості автоматизувати перевезення вантажу 
на різні дистанції за допомогою БПЛА. Це дозволить зробити отримання 
замовлень користувачам швидше та легше. Цей проєкт в майбутньому можна 
буде використовувати для власних цілей та надавати можливість компаніям 
доставки та тим, хто надає послуги перевезень вантажу використовувати цю 
систему на свою користь.
На меті є створення проєкту, який складається з декількох додатків, де 
функціонал розділений за ролями користувачів. Персонал зможе створювати 
замовлення та підключати для їх доставки БПЛА. Також персонал буде мати 
можливість легкого адміністрування системи, наприклад перегляд замовлень, їх 
обробка, перегляд інформації та ін. 
Клієнт у свою чергу зможе зробити замовлення прямо в системі, створивши 
перелік необхідних речей для відправки. Також буде можливість використання 
цієї системи для відправки посилок від клієнта до клієнта. Загалом для 
отримання посилки пропонується декілька варіантів: створення розумних точок 
отримання посилки, реєстрація спеціальних посадочних місць з QR кодом, який 
зможе розпізнати БПЛА та просто вказання необхідних координат.
Так як БПЛА мають обмежене завантаження та дальність польоту, в 
система має враховувати це, а БПЛА має можливість власноруч залетіти до 
пункту зарядки, які мають бути створені для забезпечення перевезень вантажу на 
досить далекі відстані.

Система також має надавати можливість переглядати різну інформацію про 
посилку, БПЛА, замовлення та користувачів системи. Має включати також в себе 
створення логів для відстеження історії дій в системі.

2.1.2.2. Головна функціональність

Функціонал мобільного застосунку:
MF-1: Реєстрація акаунту користувача;
MF-2: Створення замовлень;
MF-3: Керування замовленням;
MF-4: Відстежування стану замовлення;
MF-5: Отримання замовлення;
MF-6: Оплата доставки;
MF-7: Перегляд історії замовлень.
Функціонал веб застосунку:
MF-8: Реєстрація працівника у системі;
MF-9: Обробка замовлень;
MF-10: Перегляд замовлень;
MF-11: Перегляд інформації про клієнта;
MF-12: Керування БПЛА;
MF-13: Створення посадкових майданчиків для БПЛА.

3. Рамки та обмеження
2.1.3.1. Рамки первинного випуску

Основні функції, які будуть включені у перший випуск даного проєкту 
мобільному застосунку включають наступні:
SIR-1: Реєстрація акаунту користувача;
SIR-2: Створення замовлень;
SIR-3: Керування замовленням(переадресація, зміна отримувача або 
замовлення, до моменту отримання);
SIR-4: Відстежування стану замовлення;
SIR-5: Отримання замовлення за кодом або NFC;
SIR-6: Оплата доставки за допомогою сервісів оплати, включених у 
додаток;
SIR-7: Push - повідомлення;
SIR-8: Перегляд історії замовлень.
Основні функції, які були включені у перший випуск даного проєкту веб 
застосунку включають наступні:
SIR-9: Реєстрація працівника у системі;
SIR-10: Обробка замовлень(перегляд вмісту, зміна стану замовлення);
SIR-11: Перегляд усіх замовлень;
SIR-12: Перегляд інформації про клієнта;
SIR-13: Керування БПЛА(перебазування);
SIR-14: Створення точок базування/зарядки БПЛА.
Також слід зазначити, що усі дані були захищені в системі, тому паролі 
повинні зберігаються у вигляді хешу в базі даних, усі запити до сервісів та 
функцій включають в себе JWT токен користувача, який не має зберігатися 
довше, ніж 24 години, який перевіряється системою на валідність. 
Також для обробки великої кількості даних, таких, як наприклад побудова 
маршрутку для польоту безпілотного апарату був застосований алгоритм пошук 
А(A search) разом з кластерізацією точок, які розташовані поряд.
Також система повинна мати локалізацію, яка дозволить використовувати 
її користувачам з різних країн. Дата, час та мова повинні відображатись у 
користувачів в залежності від їх розташування або локалі у звичному для них 
форматі. Дані про дату та час зберігаються в універсальному форматі. 
2.1.3.2. Рамки наступних випусків
У майбутньому проєкт буде вдосконалений наступним функціоналом:
SSR-1: Створення клієнтом власних точок посадки БПЛА;
SSR-2: Інтеграція з магазинами та компаніями доставки;
SSR-3: Додання програм лояльності для клієнтів та компаній;
SSR-4: Оптимізація проєкту;
SSR-5: Оплата доставки за допомогою NFC мітки на БПЛА.

4. Бізнес контекст
2.1.4.1. Робоче середовище

Back-end цього проєкту буде написаний на Java з використанням Spring 
framework. Дана технологія забезпечить потужний та надійний back-end для 
обробки даних. Її переваги полягають у зручному та простому управлінні 
запитами, зворотній сумісності та підтримці стандартів Java EE, що дозволить 
легко масштабувати проєкт у майбутньому. Крім того, технологія Spring Data 
значно спрощує роботу з базою даних. Так як важливо забезпечити безперебійну 
роботу системи та мінімізувати перевантаження системи було обрано 
мікросервісну архітектуру. Java Spring це фреймворк, на якому як раз можна 
легко створити різні за розміром API та швидко створити мікросервіси та розбити 
проєкт на складові.

В розробці back-end складової також буде використовуватися СУБД
PostgreSQL. Це сучасна СУБД яка швидко набирає популярність. 
Mobile складова буде розроблена на мові Kotlin. Ця мова програмування, 
створена компанією Google, для заміни мови Java для створення мобільних 
застосунків та вона є популярною. Вона добре працює з Java та може взаємодіяти 
з існуючим Java кодом.
Front-end буде розроблений з використанням бібліотеки React. React це 
сучасна JS бібліотека, для створення веб інтерфейсів користувача. Вона є однією 
з найпопулярніших фреймворків або бібліотек для розробки веб додатків.
IoT пристрій, тобто БПЛА буде розроблений з використанням Arduino. Цей 
мікрокомп’ютер дуже добре обробляє аналогові сигнали з датчиків, що у 
поєднані з мовою низького рівня програмування C++ допоможе забезпечити 
швидку роботу пристрою.

2.2. Серверна частина системи
1. Концептуальне моделювання

Для реалізації серверної частини, першим кроком було створення діаграм, 
які змогли б описати проєкт. Першою була створена ER-модель даних, яка 
наведена в Додатку A (рис. A1).
Модель даних має та описує такі компоненти:
1. Користувача(Ідентифікатор, ім’я, прізвище, телефон, стать, день 
народження, роль, дата реєстрації, електрона пошта);
2. Замовлення(Ідентифікатор, ідентифікатор користувача, 
ідентифікатор станції відправлення, ідентифікатор станції отримання, номер 
замовлення, код отримання);
3. Елемент замовлення(Назва, опис, кількість, вага, чи є хрупким);
4. Засіб переміщення(Ідентифікатор, дистанція польоту, навантаження, 
норме);
5. Станція(Ідентифікатор, номер, опис, висота, широта, довгота, тип).
Сутності побудовані таким чином, щоб ефективно зберігати інформацію і 
мати можливість буди розподіленою базою даних для мікросервісів. Географічні 
координати є GPS координатами, для правильної побудови шляху та 
відображення на мапі. Також замовлення зберігає ідентифікатори для усіх 
частин, для того, щоб до кожного мікросервісу можна було звернутись за 
певними даними однаково, щоб не виникало плутанини в запитах і методах їх 
відправки.
Далі було визначено сценарії використання системи. Для цього було 
побудовано UML діаграму прецедентів. На ній було визначено 2 типи 
користувачів та усі дії, які можливі системі. Дану діаграму можна подивитись у 
Додатку А (рис. А.2).
Користувач може зареєструватись в системі, керувати замовленням, робити 
зміни доки це можливо, продивлятись історію своїх замовлень, дані про поточні 

замовлення, отримувати доставку та відстежувати стан замовлення. Користувач 
має доступ тільки до мобільного застосунку, у якій буде реалізована логіка.
Адміністратор має можливість дивитись всі замовлення, передивлятись 
інформацію про клієнта, керувати безпілотником, обробляти замовлення, 
відхиляти його, якщо це треба, створювати нові точки видачі та базування засобів 
транспортування. Даний функціонал буде розроблений у веб-застосунку, доступ 
до якого будуть мати лише адміністратори системи.
Також під час моделювання системи було створено UML - діаграму 
діяльності користувача. Дані діаграми можна побачити у Додатку А (рис. А.3).
Можемо описати діяльність звичайного користувача наступним чином: 
спочатку користувач реєструється або входить до свого аканту. Далі може 
подивитись замовлення і подивитись його стан, або може зробити нове 
замовлення. Для створення нового замовлення можна вибрати точку отримання, 
додати нові елементи замовлення та відправити його на опрацювання.
Діяльність адміністратора системи можна описати наступним чином: 
адміністратор заходить у свій акаунт в системі. Після цього Він може отримати 
список замовлень, після чого обрати замовлення для обробки та його обробити, 
або подивитись історію замовлень, або відстежувати засоби транспортування, 
після чого може обрати певний засіб і переглянути інформацію про нього, або 
створити нову точку базування або видачі товарів. 

2. Інженерні рішення
2.2.2.1. Структура та технології

Вибір технологій для розробки цієї частини був обраний згідно 
функціональних вимог системи. Так як система буде мати велике навантаження 
через важкі математичні методи, було обрано мікросервісну архітектуру для 
розробки. Так як система має бути розроблена стабільною, було вирішено 

використовувати Java та Spring Framework для розробки основної логіки, а шлюз 
для розподілення запитів на NestJS через незначну логіку та простоту написання. 
Спілкування з сервісами буде реалізовано за допомогою REST API. 
Також було вирішено зробити розподілену базу даних і розділити її на User, 
Vehicle-Station та реалізувати у СУБД PostgreSQL тому що дані сутності мають 
чітко визначену структуру. Базу даних Order було вирішено реалізувати на 
NoSQL БД MongoDB, через дуже часту змінювану та не чітку структуру 
сутностей. Це дозволить краще та легше обробляти об’єкти з різною структурою.
Комунікація між сервісами буде реалізована за допомогою стандартних 
HTTP-методів. Шлюз має проксувати запити на окремі сервіси, а сервіси зможуть 
спілкуватись між собою. 
Така розподілена система дозволить зменшити навантаження на всю 
систему, а допоможе зробити захист даних більш кращим за рахунок того що 
один сервіс не має доступу до всіх даних.
Було створено UML-діаграму розгортання проєкту Додаток А (рис. А4)

2.2.2.2. Опис архітектури

Проєкт складається з декількох сервісів, які мають схожу між собою 
структуру. Спочатку було створено контролери сервісів, які забезпечують прийом 
та обробку запитів. Було створено наступні контролери: AuthenticationController, 
UserController, VehicleController, StationController, OrderController. Приклад коду 
контролеру AuthenticationController наведено у Додатку Б.
Першим чином розберемо структуру контролеру. Він мість анотації: 
@RestController для визначення, що цей клас є контролером, далі 
@RequestMapping("/user-service/auth") для визначення шляху до цього 
контролеру та @RequiredArgsConstructor для автоматичної генерації 
конструктору класу з включеними у неї іншими частинами проєкту, які визначені 
в коді. Далі @Operation це анотація swagger для генерування документації. Далі 
можна побачити анотації @PostMapping. Вони визначають шлях до конкретних 
функцій контролеру. Анотація @RequestBody визначає, що функція має 
приймати тіло запиту певного типу, воно визначено класом. Анотація 
@RequestParam вказує на те, що функція приймає параметр. ResponseEntity.ok()
це сутність відповіді, в якій можна передати різні типи відповіді та тіло запиту. 
Для початку для роботи з базою даних було створено об’єкти, такі як: User, 
Order, Item, Vehicle та Station. Приклад сутності бази даних Station можна 
побачити далі:
1. @Data
2. @Builder
3. @NoArgsConstructor
4. @AllArgsConstructor
5. @Entity
6. @Table(name = "station")
7. @ToString(exclude = "vehicles")
8. public class Station {
9. @Id
10. @GeneratedValue(strategy = GenerationType.SEQUENCE, 
generator = "station_seq_gen")
11. @SequenceGenerator(name = "station_seq_gen", 
sequenceName = "station_seq", allocationSize = 1)
12. private Integer id;
13. private String number;
14. private String description;
15. @Enumerated(EnumType.STRING)
16. private Type type;
17. private Double latitude;
18. private Double longitude;
19. private Double altitude;
20. @OneToMany(mappedBy = "station")
21. @JsonIgnore
22. private List<Vehicle> vehicles;
23. }
В даній сутності можна побачити звичайні поля для зберігання інформації. 
Дуже важливі геопросторові дані зберігаються як число з плаваючою точкою. Це 
дозволить легко обробляти їх у майбутньому. Можна побачити анотації 
бібліотеки Lombok: @Builder, @NoArgsConstructor, @AllArgsConstructor та 
@ToString(exclude = "vehicles"). Вони автоматично генерують гетери та сетери 
полів та метод перетворення в рядок, який виключає поле за назвою. 
Для отримання запиту та відправки відповіді також можуть 
використовуватись різні спеціальні класи, для структуризації відповіді. Було 
створено такі класи: AuthenticationRequest, AuthenticationResponse, 
RegisterRequest, StationAddRequest, StationChangeRequest, 
StationGetAllResponseEntity, IsSuitableRequest, VehicleAddRequest, 
VehicleChangeRequest, VehicleGetAllResponseEntity, IsSuitableRequestEntity, 
OrderAddRequestEntity, OrderChangeRequestBody, OrderProcessRequestBody, 
OrderSendRequestBody, OrderAdminGetResponseEntity, 
OrderUserGerResponseEntity, OrderVehicleGetRepsonse. Ось приклад сутності 
OrderAddRequestEntity:
1. @Data
2. @Builder
3. @AllArgsConstructor
4. @NoArgsConstructor
5. public class OrderAddRequestBody {
6. private String arrivalStationNumber;
7. private ZonedDateTime creationDate;
8. private List<Item> items;
9. }
Дана сутність має певні поля, які мають бути передані в запиті до функції. 
Це дозволяє керувати поведінкою програми. 
Далі були створені сервіси для основної логіки застосунку, так як: 
AuthenticationService, UserService, JwtService, VehicleService, StationService, 
OrderService. Приклад коду сервісу AuthenticationService наведено у додатку Б.
Він має анотацію @Service, яка говорить програмі, що це сервіс. Також має 
в собі функції з коментарями у форматі JavaDoc та обєкти типу репозиторій. В 
цих сервісах реалізована уся логіка програми та зпити до БД, але пряму 
взаємодію з БД реалізують репозиторії. Сервіс, наведений в прикладі це сервіс 
авторизації, який створений для того, щоб реєструвати користувача, 
аутентифікавути його та перевіряти чи має він певну роль та права.
Ось приклад репозиторію OrderRepository:
1. public interface OrderRepository extends 
MongoRepository<Order, String> {
2. Optional<Order> findByNumberAndStatusNotLike (String 
number, Status status);
3. 
4. Optional<Order> findByVehicleIdAndStatusLike(Integer 
vehicleId, Status status);
5. 
6. Optional<List<Order>> findAllByUserId(Integer userId);
7. }
Це репозиторій для запитів в БД, який є основою SpringDataJPA, яка в свою 
чергу є ОРМ Hibernate. Вона здатна створювати складні запити лише за 
допомогою створення правильної назви функції, наприклад
findByNameLikeAndNumberEquals. Це повністю заміняє написання нативних 
запитів мовою SQL. Optional<T> це клас, який у разі того, що нічого не було 
знайдено, поверне пустий елемент, і не буде помилки, як наприклад з перевіркою 
параметрів в null об’єкті. 
Також були створені конфігураційні файли, які допомагають системі 
правильно завантажитися та мати певну поведінку після запуску. Ось приклад 
конфігурація SecurityConfiguration в auth-service:
1. @Configuration
2. @EnableWebSecurity
3. @RequiredArgsConstructor
4. public class SecurityConfig {
5. 
6. private final JwtAuthenticationFilter 
jwtAuthenticationFilter;
7. private final AuthenticationProvider 
authenticationProvider;
8. 
9. @Bean
10. public SecurityFilterChain 
securityFilterChain(HttpSecurity http) throws Exception{
11. http
12. .csrf(AbstractHttpConfigurer::disable)
13. .cors(Customizer.withDefaults())
14. .authorizeHttpRequests(auth ->
15. auth.requestMatchers("/userservice/auth/**").permitAll()
26
16. .requestMatchers("/userservice/user/get-userId").hasAuthority("USER")
17. .requestMatchers("/userservice/user/**").hasAuthority("ADMIN")
18. .requestMatchers(
19. "/v2/api-docs",
20. "/v3/api-docs/**",
21. "/swagger-resources",
22. "/swaggerresources/**",
23. "/configuration/ui",
24. "/configuration/security",
25. "/swagger-ui/**",
26. "/webjars/**",
27. "/swagger-ui.html",
28. "/swaggerui/index.html"
29. ).permitAll()
30. .anyRequest().authenticated()
31. )
32. .sessionManagement(session ->
33. 
session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
34. )
35. 
.authenticationProvider(authenticationProvider)
36. .addFilterBefore(jwtAuthenticationFilter, 
UsernamePasswordAuthenticationFilter.class);
37. 
38. return http.build();
39. }
40. }
Дана частина системи має спеціально анотацію яка робить її 
конфігураційним файлом. Це конфігурація захисту сервісу аутентифікації. Вона 
дозволяє визначити які запити можуть бути аутентифіковані, а які можуть 
проходити без перевірки. Так як частина фреймворку, яка відповідає за захист 
системи з кожним разом змінюється, структура, яка визначає конфігурацію 
змінюється. Для даного проєкту було визначено, що запити, які надходять в 
сервіс авторизації можуть бути пропущені auth.requestMatchers("/userservice/auth/**").permitAll(), а усі інщі мають бути аутентифіковані
.anyRequest().authenticated(). Для аутентифікації використовується 
SecurityFilterChain, яка робить все автоматично. Також деякі запити можуть бути 
пропущені не для всіх, а для тих, хто має певну ролі та права, тому функціонал 
для адміністратора можна відокремити наступним чином .requestMatchers("/userservice/user/**").hasAuthority("ADMIN").
Також для даних були створені перечислення, для визначення наприклад 
статусів або типів замість зберігання рядка. Ось наприклад статуси замовлення:
1. public enum Status {
2. CREATED,
3. PROCESSED,
4. SENT,
5. DELIVERED,
6. RECEIVED,
7. DENIED
8. }
Використання таких класів для визначення певних параметрів класів 
дозволяє зберігати визначену системою структуру. Це дозволяє уникнути 
помилок з типами та статусами.
Найважливішою частиною логіки даної системи є алгоритм пошуку шляху 
для дрону. Це алгоритм А* який реалізований разом з кластерізацією точок та 
функцією розрахунку відстані між координатами. Код наведено у Додатку Б. Далі 
будуть наводитись частини цього коду.
Цей код реалізує логіку для управління транспортними засобами через API, 
включаючи надсилання транспорту, перевірку доступності та обробку запитів. 
Перший метод, sendVehicle, виконує ряд перевірок: аутентифікація користувача, 
пошук транспорту у базі даних, виклик зовнішньої служби для отримання 
замовлення та підготовка маршруту. Код перевіряє, чи є користувач 
адміністратором. У разі невдачі викидається виняток. Якщо транспортний засіб 
не знайдено за номером, генерується інший виняток. Знайдений транспортний 
засіб робить HTTP-запит до сервісу замовлень для отримання замовлення. 
Програма обробляє можливі помилки у відповіді та визначає географічні 
координати початку і кінця маршруту, використовуючи відкриті дані для 
планування перетинів.
Для отримання гео-просторових даних для початку рахується мінімальні та 
максимальні координати прямокутної області з урахуванням дозволеного буферу:
48. Double startLat, startLon, endLat, endLon;
49. startLat = deptStation.getLatitude();
50. startLon = deptStation.getLongitude();
51. endLat = arvlStation.getLatitude();
52. endLon = arvlStation.getLongitude();
53. 
54. double minLat = Math.min(startLat, endLat) -
BUFFER_RADIUS;
55. double maxLat = Math.max(startLat, endLat) + 
BUFFER_RADIUS;
56. double minLon = Math.min(startLon, endLon) -
BUFFER_RADIUS;
57. double maxLon = Math.max(startLon, endLon) + 
BUFFER_RADIUS;
58. 
59. Set<Point> crossings;
60. try {
61. crossings = 
loadCrossingsFromOpenStreetMap(minLat, minLon, maxLat, maxLon);
62. } catch (Exception e) {
63. throw new RuntimeException(e);
64. }
65.
Далі функція робить запит до відкритого Overpass-turbo API для отримання 
відкритих гео-просторових даних на визначеній ділянці:
106. public Set<Point> loadCrossingsFromOpenStreetMap(double 
minLat, double minLon, double maxLat, double maxLon) throws 
Exception {
107. String url = "https://overpassapi.de/api/interpreter";
108. String data = "[out:json];" +
109. "(node[\"highway\"=\"crossing\"](" + minLat 
+ "," + minLon + "," + maxLat + "," + maxLon + ");" +
110. "node[\"highway\"=\"turning_circle\"](" + 
minLat + "," + minLon + "," + maxLat + "," + maxLon + "););" +
111. "out;";
112. String fullUrl = url + "?data=" + data;
113. 
114. RestTemplate restTemplate = new RestTemplate();
115. ResponseEntity<String> response = 
restTemplate.getForEntity(fullUrl, String.class);
116. 
117. Set<Coordinate> crossings = new HashSet<>();
118. 
119. if (response.getStatusCode().is2xxSuccessful()) {
120. String responseBody = response.getBody();
121. ObjectMapper mapper = new ObjectMapper();
122. JsonNode root = mapper.readTree(responseBody);
29
123. JsonNode elements = root.path("elements");
124. 
125. for (JsonNode element : elements) {
126. double lat = element.get("lat").asDouble();
127. double lon = element.get("lon").asDouble();
128. crossings.add(new Coordinate(lon, lat));
129. }
130. } else {
131. throw new RuntimeException("Failed to fetch 
crossings data");
132. }
133. 
134. Set<Point> clusteredCrossings = 
clusterPoints(crossings);
135. 
136. return clusteredCrossings;
137. }
На початку формується запит до API, після чого він робиться за допомогою 
рядка 115. Також слід зазначити, що відкритий API, який використовується, має 
свою «мову» для отримання даних, тому також було сформовано рядок параметр, 
який відповідає за отримання даних. Після чого з 119 по 132 рядок відповідь 
оброблюється . На рядку 134 викликається функція кластерізації. Це робиться 
для того, щоб прибрати зайві гео-просторові дані, які можна об’єднати в одну 
точку, якщо вони розташовані поряд:
72. private Set<Point> clusterPoints(Set<Coordinate> 
coordinates) {
73. List<DoublePoint> doublePoints = new ArrayList<>();
74. for (Coordinate coordinate : coordinates) {
75. doublePoints.add(new DoublePoint(new 
double[]{coordinate.y, coordinate.x}));
76. }
77. 
78. DBSCANClusterer<DoublePoint> clusterer = new 
DBSCANClusterer<>(EPS, MIN_POINTS);
79. List<Cluster<DoublePoint>> clusters = 
clusterer.cluster(doublePoints);
80. 
81. Set<Point> clusteredPoints = new HashSet<>();
82. Set<DoublePoint> clusteredDoublePoints = new 
HashSet<>();
83. 
84. for (Cluster<DoublePoint> cluster : clusters) {
85. double sumLat = 0, sumLon = 0;
86. for (DoublePoint doublePoint : 
cluster.getPoints()) {
30
87. double[] values = doublePoint.getPoint();
88. sumLat += values[0];
89. sumLon += values[1];
90. clusteredDoublePoints.add(doublePoint);
91. }
92. double meanLat = sumLat / 
cluster.getPoints().size();
93. double meanLon = sumLon / 
cluster.getPoints().size();
94. clusteredPoints.add(new Point(meanLat, meanLon));
95. }
96. 
97. for (DoublePoint doublePoint : doublePoints) {
98. if (!clusteredDoublePoints.contains(doublePoint)) 
{
99. double[] values = doublePoint.getPoint();
100. clusteredPoints.add(new Point(values[0], 
values[1]));
101. }
102. }
103. 
104. return clusteredPoints;
105. }
Дана функція використовує алгоритм кластерізації DBSCAN. Спочатку 
координати перетворюються в список об’єктів DoublePoint для обробки у рядках 
73-76. Далі проводиться кластерізація всіх точок, які знаходяться поряд одна з 
одною(рядок 84-95). Після цього у другому циклі додаються точки, які не були 
кластерізовані(рядок 97-102). Після цього повертається масив кластерізованих 
точок.
Наступні функції виконують допоміжну роботу, бо вони є частиною 
алгоритму, тільки винесені в окремі функції:
172. private List<Point> getNeighbors(Point point, Set<Point> 
crossings) {
173. List<Point> neighbors = new ArrayList<>();
174. for (Point crossing : crossings) {
175. double dist = distance(point, crossing);
176. if (!crossing.equals(point) && dist < 
MIN_NEIGHBOUR_DISTANCE) {
177. neighbors.add(crossing);
178. }
179. }
180. return neighbors;
181. }
31
Дана функція шукає сусідів в заданій області. Відстань, яку можна вважати 
близькою для сусіда винесено в константу MIN_NEIGHBOUR_DISTANCE. 
Далі функція для реконструкції шляху:
183. private List<Point> reconstructPath(Map<Point, Point> 
cameFrom, Point current) {
184. List<Point> path = new ArrayList<>();
185. path.add(current);
186. while (cameFrom.containsKey(current)) {
187. current = cameFrom.get(current);
188. path.add(current);
189. }
190. Collections.reverse(path);
191. return path;
192. }
Вона обробляє Map колекцію та переводить її в потрібний для пошуку 
шляху вигляд. 
Далі функції пошуку відстані між координатами: 
193. private double distance(Point p1, Point p2) {
194. double lat1 = Math.toRadians(p1.getLatitude());
195. double lon1 = Math.toRadians(p1.getLongitude());
196. double lat2 = Math.toRadians(p2.getLatitude());
197. double lon2 = Math.toRadians(p2.getLongitude());
198. 
199. double dlon = lon2 - lon1;
200. double dlat = lat2 - lat1;
201. double a = Math.pow(Math.sin(dlat / 2), 2)
202. + Math.cos(lat1) * Math.cos(lat2)
203. * Math.pow(Math.sin(dlon / 2), 2);
204. 
205. double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 
- a));
206. double r = 6371; // Радіус Землі в кілометрах
207. return c * r;
208. }
209. 
210. private double distance(double lat1, double lon1, 
double lat2, double lon2) {
211. lat1 = Math.toRadians(lat1);
212. lon1 = Math.toRadians(lon1);
213. lat2 = Math.toRadians(lat2);
214. lon2 = Math.toRadians(lon2);
215. 
216. double dlon = lon2 - lon1;
217. double dlat = lat2 - lat1;
218. 
32
219. double a = Math.pow(Math.sin(dlat / 2), 2)
220. + Math.cos(lat1) * Math.cos(lat2)
221. * Math.pow(Math.sin(dlon / 2), 2);
222. double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 
- a));
223. double r = 6371;
224. 
225. return c * r;
226. }
Ці дві функції однакові, але приймають різні параметри. Це алгоритм 
Гаверсінуса для знаходження відстані на кулі за координатами. Він з високою 
точністю розраховує відстань. Спочатку перетворює граду у радіани, після чого 
розраховує різницю широти та довготи. Потім визначає кут між точками і в кінці 
рахує відстань.

2.2.2.3. Специфікація REST API

Сутність Метод Посилання Дія
User POST /user-service/auth/register Реєстрація
User POST /user-service/auth/authenticate Аутентифікація
User GET /user-service/auth/ping Пінг
User GET /user-service/auth/is-valid Перевірка токена на 
валідність
User GET /user-service/auth/is-user Перевірка токена на 
роль користувача
User GET /user-service/auth/is-admin Перевірка токена на 
роль адміністратора
User GET /user-service/user/ping Пінг
33
Продовження таблиці 1
User GET /user-service/user/id Отримати 
користувача за id 
User GET /user-service/user/get-userId Отримати id 
користувача
User GET /user-service/user/get-user-email Отримати пошту 
користувача
User GET /user-service/user/all Отримати всіх 
користувачів
Vehicle PUT /vehicle-station-service/vehicle/getvehicle-ready
Змінити стан дрона 
Vehicle PUT /vehicle-stationservice/vehicle/change
Змінити інформацію 
про дрон
Vehicle POST /vehicle-station-service/vehicle/add Додати дрон
Vehicle GET /vehicle-station-service/vehicle/send Отримати шлях у 
GPS координатах
Vehicle GET /vehicle-station-service/vehicle/ping Пінг
Vehicle GET /vehicle-station-service/vehicle/issuitable
Чи підходить 
замовлення для 
дрона
Vehicle GET /vehicle-station-service/vehicle/getnumber
Отримати номер 
дрона
34
Продовження таблиці 1
Vehicle GET /vehicle-station-service/vehicle/get-id Отримати id дрона
Vehicle GET /vehicle-station-service/vehicle/get-all Отримати всіх 
дронів
Vehicle DELETE /vehicle-station-service/vehicle/delete Видалити дрон
Station PUT /vehicle-stationservice/station/change-station
Змінити інформацію 
про станцію
Station POST /vehicle-station-service/station/add Додати станцію
Station GET /vehicle-station-service/station/ping Пінг
Station GET /vehicle-station-service/station/getnumber
Отримати номер 
станції
Station GET /vehicle-station-service/station/get-id Отримати id станції
Station GET /vehicle-station-service/station/get-all Отримати всі станції
Station DELETE /vehicle-station-service/station/delete Видалити станцію
Order PUT /order-service/update-status Змінити статус 
замовлення
Order PUT /order-service/process Обробити 
замовлення
Order PUT /order-service/change Змінити інформацію 
про замовлення
Order POST /order-service/add Додати замовлення
Order GET /order-service/statuses Отримати статуси 
замовлення
35
Продовження таблиці 1
Order GET /order-service/ping Пінг
Order GET /order-service/get-orders-for-user Отримати 
замовлення для 
юзера
Order GET /order-service/get-order-for-vehicle Отримати 
замовлення для 
дрона
Order GET /order-service/get-all Отримати всі 
замовлення

2.2.2.4. Тестування

Тестування даної частини було зроблено за допомогою документації 
openAPI з використанням інтерфейсу Swagger. Цей інструмент дозволяє 
автоматично генерувати запити та тіла або параметри запитів, що значно 
прискорює тестування запитів та функцій серверу. Swagger UI відкривається як 
HTML сторінка, з Відокремленими запитами, тілом запиту, параметрами, 
можливими відповідями і описом. Також при тестуванні використовувались Json 
Web Tokens для авторизації та доступу тільки до функцій, визначених для певної 
ролі користувачів системи.
Під час тестування робота сервеної частини була перевірена за допомогою 
надсилання HTTP запитів на контролери мікросервісів. Використовувались різні 
методи запиту, такі як GET, PUT, POST та DELETE. Була перевірена 
інтернаціоналізація дати та часу при додаванні до БД або при зміні цієї дати. 
Після тестування було виявлено помилки в функціонуванні серверу, які 
було виправлено. Після цього знову були проведені тести, які показали, що сервер 
працює правильно, добре обробляє дані і швидко надсилає відповіді.

2.3. Front-end частина проєкту
1. Структура та технології

На початку розробки Front-end частини було створено деякі UML діаграми 
для її опису. Розглянемо їх далі.
На початку було створено UML-діаграму прецедентів(рис. А2). Дана 
діаграма показує, які функції користувач, а саме адміністратор має виконувати. 
Передбачено, що користувач буде переглядати усі замовлення, обробляти 
замовлення, переглядати інформацію про користувачів системи, керувати 
безпілотним апаратом, а саме: відправка та передислокація та перегляд 
інформації про літальні апарати і точки базування та видачі замовлень. 
Далі було створено UML-діаграму діяльності(рис. А3), яка показує 
можливу послідовність дій адміністратора системи. На початку потрібно увійти 
в систему, після чого адміністратор може отримати список замовлень, після чого 
обрати замовлення для обробки, ввести необхідні дані для обробки і обробити 
замовлення, або просто переглянути інформацію про замовлення, або обрати 
безпілотний апарат і виконати певні дії з ним, або створити точку базування та 
переглянути інформацію про всі точки. 
Далі було створено UML-діаграму компонентів(рис. А5), яка показує, які 
компоненти мають бути в проєкті. На діаграмі бачимо, що застосунок має 
головний файл App.tsx, до якого підв’язані необхідні елементи сторінки та саме 
сторінки, такі як: Users.tsx, Orders.tsx, Stations.tsx, Vehicles.tsx, Authentication.tsx
та елементи, такі як: MainContent.tsx, Header.tsx, Footer.tsx, PrivateRoute.tsx. 
AuthContext.tsx це файл стану аутентифікації, в ньому буде зберігатись 
інформація про користувача, який увійшов у систему та його токен для 
подальших дій. Також до головних вікон відносяться допоміжні, для створення 
та редагування елементів наприклад: OrderProcess.tsx, StationChange.tsx, 
StationCreate.tsx, VehicleChange.tsx, VehicleCreate.tsx. Також є такі компоненти, 
які сервіси, в яких реалізована логіка, для зв’язку з сервером: AuthService, 
UserService, VehicleService, OrderService, StationService.
На останок було створено UML-діаграму станів(рис. А6), яка відображає 
усі можливі стани проєкту. На ній можна бачити 4 головних елементи: Users, 
Vehicles, Stations та Orders. В середині них можна побачити які функції в проєкті 
за що відповідають і є певна послідовність, яка відображає стани елементів.
Для розробки даної частини було використано бібліотеку ReactJS разом з
мовою програмування Typescript. Ознайомимось з прикладами програмного 
коду.
Частина програмного коду App.tsx:
1. const App: React.FC = () => {
2. return (
3. <Router>
4. <AuthProvider>
5. <CssBaseline/>
6. <div className="App">
7. <Header/>
8. <MainContent>
9. <Routes>
10. <Route path="/login" 
element={<Authentication/>}/>
11. <Route element={<PrivateRoute/>}>
12. <Route path="/users" 
element={<Users />} />
13. <Route path="/vehicles" 
element={<Vehicles />} />
14. <Route path="/vehicles/create" 
element={<VehicleCreate />} />
15. <Route path="/vehicles/change/:id" 
element={<VehicleChange />} />
16. <Route path="/stations" 
element={<Stations />} />
17. <Route path="/stations/create" 
element={<StationCreate />} />
18. <Route path="/stations/change/:id" 
element={<StationChange />} />
19. <Route path="/orders" 
element={<Orders />} />
20. <Route path="/orders/process/:id" 
element={<OrderProcess />} />
21. </Route>
22. </Routes>
23. </MainContent>
39
24. <Footer/>
25. </div>
26. </AuthProvider>
27. </Router>
28. );
29. };
Цей файл є головним файлом додатку, в який включаються ясі елементи, 
які мають бути відображені на сторінці. За допомогою спеціальних тегів <Route>
було визначено маршрути до кожного елементу. Також можна побачити ще деякі 
елементи, наприклад <Header>, <Footer>, <MainContent>, які є окремими 
компонентами сторінкикомпонентами.
Код компонента Header.tsx:
1. const HeaderContainer = styled.header`
2. background: #333;
3. color: white;
4. padding: 1em;
5. `;
6. 
7. const Nav = styled.nav`
8. ul {
9. list-style: none;
10. padding: 0;
11. display: flex;
12. gap: 1em;
13. }
14. 
15. a {
16. color: white;
17. text-decoration: none;
18. }
19. `;
20. 
21. const Header: React.FC = () => {
22. return (
23. <HeaderContainer>
24. <Nav>
25. <ul>
26. <li>
27. <Link to="/orders">Orders</Link>
28. </li>
29. <li>
30. <Link to="/users">Users</Link>
31. </li>
32. <li>
33. <Link to="/vehicles">Vehicles</Link>
40
34. </li>
35. <li>
36. <Link to="/stations">Stations</Link>
37. </li>
38. <li>
39. <Link to="/login">Login</Link>
40. </li>
41. </ul>
42. </Nav>
43. </HeaderContainer>
44. );
45. };
Цей файл містить в собі стилі для елементів компоненту та головну 
функцію, яка повертає його структуру.
Далі наведено код AuthContext.tsx:
1. interface AuthContextProps {
2. isAuthenticated: boolean;
3. token?: string | null;
4. login: (email: string, password: string) => 
Promise<void>;
5. logout: () => void;
6. }
7. 
8. const AuthContext = createContext<AuthContextProps | 
undefined>(undefined);
9. 
10. const AuthProvider: React.FC<{ children: ReactNode }> = 
({children}) => {
11. const [isAuthenticated, setIsAuthenticated] = 
useState<boolean>(false);
12. const [token, setToken] = useState<string | 
null>(localStorage.getItem('user') ? 
JSON.parse(localStorage.getItem('user')!).token : null);
13. 
14. useEffect(() => {
15. const user = localStorage.getItem('user');
16. if (user) {
17. setIsAuthenticated(true);
18. setToken(JSON.parse(user).token);
19. }
20. }, []);
21. 
22. const login = async (email: string, password: string) 
=> {
23. const result = await AuthService.login(email, 
password);
24. if (result.isAuthenticated && result.token) {
41
25. localStorage.setItem('user', 
JSON.stringify({token: result.token}));
26. setToken(result.token);
27. setIsAuthenticated(true);
28. } else {
29. console.error('Login failed or user is not an 
administrator.');
30. setIsAuthenticated(false);
31. }
32. };
33. 
34. const logout = () => {
35. localStorage.removeItem('user');
36. setToken(null);
37. setIsAuthenticated(false);
38. };
39. 
40. return (
41. <AuthContext.Provider value={{isAuthenticated, 
token, login, logout}}>
42. {children}
43. </AuthContext.Provider>
44. );
45. };
46. 
47. export {AuthContext, AuthProvider};
Цей контекст створений для збереження стану користувача. Коли 
користувач проходить аутентифікацію, його токен та стан аутентифікації 
зберігається і використовується в інших частинах проєкту.
Нижче наведено код сервісу AuthService:
1. interface LoginResponse {
2. token: string;
3. }
4. 
5. interface AuthResult {
6. isAuthenticated: boolean;
7. token?: string;
8. }
9. 
10. const API_URL = 'http://localhost:8082/user-service/auth/';
11. 
12. const login = async (email: string, password: string): 
Promise<AuthResult> => {
13. try {
14. const authResponse = await 
axios.post<LoginResponse>(API_URL + 'authenticate', {
42
15. email,
16. password
17. });
18. 
19. const {token} = authResponse.data;
20. 
21. const isAdminResponse = await 
axios.get<boolean>(`${API_URL}is-admin?token=${token}`);
22. 
23. if (isAdminResponse.data) {
24. localStorage.setItem('user', 
JSON.stringify({token}));
25. console.log('Token: ' + token);
26. return {isAuthenticated: true, token};
27. } else {
28. throw new Error("User is not an administrator");
29. }
30. } catch (error) {
31. console.error("Authentication failed:", error);
32. return {isAuthenticated: false};
33. }
34. };
У цьому коді є інтерфейси, які використовуються для надсилання та 
отримання певного формату даних. Також є функція login, яка відправляє запит 
на сервер для проходження аутентифікації. Якщо все добре, вона отримує токен 
користувача та зберігає його.
Далі подивимось на код сторінки Orders.tsx, який наведено у додатку Б. 
Можемо бачити інтерфейс Order, який використовується для отримання даних з 
серверу, та AdaptedOrder, який використовується для форматування даних в 
певний вигляд для відображення в таблиці. Також є tableHeader – заголовки 
таблиці. Функція Orders відображає дані на сторінці, але перед цим отримує дані 
з серверу за допомогою useEffect, перевірки контексту аутентифікації та функція, 
яка визначена в сервісі OrderService.ts. 

2. Інтерфейс користувача та опис роботи застосунку

Після відкриття застосунку, користувача зустрічає вікно входу в 
систему(рис. 1).
Користувачу треба ввести персональні дані для входу, а саме електрону 
скриньку та пароль(рис. 2).
Після входу в систему, користувач попадає у вікно користувачів(рис.3).
На ньому у таблиці відображається інформація про користувачів системи. 
Дата та час виводяться у локальному форматі.
Далі користувач може перейти на вікно безпілотних засобів та подивитись 
інформацію про них(рис. 4).
На цій сторінці можна побачити інформацію про безпілотні апарати, 
зареєстровані в системі, їх положення та стан.
Далі користувач може додати новий засіб до системи після натискання на 
кнопку Create(рис. 5).
Відкрилось вікно додавання, в якому треба ввести необхідну інформацію, 
а саме дистанцію польоту, вантажопідйомність та станцію, на якій він 
базується(рис. 6).
Як бачимо, новий безпілотний апарат з’явився у системі(рис. 7).
Далі користувач може змінити інформацію про засіб, натиснувши на 
кнопку в потрібному рядку Change(рис. 8).
Кнопка SEND відповідає за логіку, яка відправляє запит на завантаження 
маршруту між точками в безпілотний засіб.
Після зміни інформації про вантажопідйомність безпілотного 
апарату(рис.9) користувач потрапляє на вікно безпілотних апаратів(рис. 10).
Дані успішно змінились.
Далі користувач може перейти на вікно станцій(рис. 11).
На цьому вікні можна бачити, де знаходиться станція, та засоби, які на ній 
розташовані.
Далі аналогічно до безпілотних засобів користувач може додати нову 
станцію(рис. 12-13).
Після натискання на Save нова станція додається до системи(рис. 14).
Також можна змінити інформацію про станцію, натиснувши кнопку 
Change у потрібному рядку(рис 15-16)
Також бачимо інформація успішно змінилась(рис. 17).
Далі користувач може перейти на вікно замовлень(рис. 18).
На цьому вікні користувач може бачити інформацію про замовлення, хто 
її замовив, станції відправки видачі та ще деяку інформацію.
Користувач може обробити замовлення натиснувши кнопку Change у 
відповідному рядку(рис. 19).
Після треба ввести інформацію про елементи замовлення, а саме їх вагу, 
після цього обрати станцію відправлення та безпілотний апарат, який на ній 
знаходиться(рис. 20)
Дані успішно змінились(рис. 21).
Також можемо бачити, що стан безпілотного апарату змінився (рис. 22)

3. Висновки

Програмна система «програмна система керування вантажо-переміщенням 
за допомогою безпілотних апаратів» частково була реалізована у відповідності 
до завдання курсової роботи.
Під час розробки програмної системи було вивчено сучасні підходи до 
побудови високонавантажених систем, архітектурні рішення та архітектури 
програмного забезпечення. Було вирішено використовувати мікросервісну 
архітектуру у поєднанні з сервіс-орієнтовною. Було вивчено такі фреймворки, як
Spring Framework та NestJs, а також бібліотеку ReactJS. У Spring Framework 
також вивчено такі його складові, як: Spring Web, Spring Boot, Spring Data та 
Spring Security. Разом з цим було використано нову NoSQL базу даних MongoDB.
Дана програмна система дозволяє створювати замовлення, обробляти їх, 
створювати та редагувати інформацію про безпілотні апарати, створювати та 
редагувати точки базування та отримання замовлень. 
Нажаль мобільний клієнтський застосунок та IoT у вигляді безпілотного 
літального апарату не було реалізовано, але ці частини проєкту будуть 
реалізовані у майбутньому. 
Дана програмна система дозволить розвинути новий підхід для 
перевезення вантажу, дозволить значно скоротити витрати на пальне, дозволить 
інтегрувати нові технології для покращення обслуговування користувачів та 
пришвидшить сферу перевезень вантажу

Перелік джерел посилання
1. Spring framework documentation https://docs.spring.io/springframework/reference/index.html
2. ReactJS documentation https://legacy.reactjs.org/docs/gettingstarted.html
3. Design Patterns: Elements of Reusable Object-Oriented Software 1995 -
396с.
4. Spring Security documentation https://docs.spring.io/springsecurity/reference/index.html
5. OpenStreetMap wiki https://wiki.openstreetmap.org/wiki/Overpass_API
6. Відео захисту https://youtu.be/mEnLLG-iqcs?si=gjStLE2Xq_QbCj5R
7. GitHub репозиторій https://github.com/NureFatianovDaniil/apzkr-pzpi21-4-fatianov-danii

Додаток Б
Код проєкту
Код AuthenticationController:
1. @RestController
2. @RequestMapping("/user-service/auth")
3. @RequiredArgsConstructor
4. public class AuthenticationController {
5. 
6. private final AuthenticationService 
authenticationService;
7. 
8. @Operation(summary = "Register a new user",
9. description = "Registers a new user and returns 
authentication details.",
10. responses = {
11. @ApiResponse(responseCode = "200", 
description = "User registered successfully"),
12. @ApiResponse(responseCode = "400", 
description = "Invalid request data")
13. })
14. @PostMapping("/register")
15. public ResponseEntity<AuthenticationResponse> register(
16. @RequestBody RegisterRequest request
17. ){
18. return 
ResponseEntity.ok(authenticationService.register(request));
19. }
20. 
21. @Operation(summary = "Authenticate a user",
22. description = "Authenticates a user and returns 
authentication token.",
23. responses = {
24. @ApiResponse(responseCode = "200", 
description = "Authentication successful"),
25. @ApiResponse(responseCode = "401", 
description = "Authentication failed")
26. })
27. @PostMapping("/authenticate")
28. public ResponseEntity<AuthenticationResponse> register(
29. @RequestBody AuthenticationRequest request
30. ){
31. return 
ResponseEntity.ok(authenticationService.authenticate(request));
32. }
33. 
67
34. @Operation(summary = "Check admin rights",
35. description = "Checks if the token provided 
belongs to an admin user.",
36. responses = {
37. @ApiResponse(responseCode = "200", 
description = "Admin rights confirmed"),
38. @ApiResponse(responseCode = "400", 
description = "Bad request, invalid token")
39. })
40. @GetMapping("/is-admin")
41. public ResponseEntity<Boolean> isAdmin(
42. @RequestParam String token
43. ) {
44. try{
45. return 
ResponseEntity.ok().body(authenticationService.isAdmin(token));
46. }catch(Exception ex){
47. return ResponseEntity.badRequest().body(false);
48. }
49. 
50. }
51. }
Код AuthenticationService:
1. @Service
2. @RequiredArgsConstructor
3. public class AuthenticationService {
4. 
5. private final UserRepository userRepository;
6. 
7. private final PasswordEncoder passwordEncoder;
8. 
9. private final JwtService jwtService;
10. 
11. private final AuthenticationManager 
authenticationManager;
12. 
13. /**
14. * Registers a new user in the system based on the 
provided registration details and issues a JWT token.
15. * This method takes a registration request containing 
user details, creates a new user entity, saves it in the database,
16. * and generates a JWT token for the newly registered 
user.
17. *
18. * <p>Key operations include:
19. * <ul>
20. * <li>Building a new user entity from the 
registration request details.</li>
68
21. * <li>Encoding the user's password for secure 
storage.</li>
22. * <li>Saving the new user entity to the user 
repository.</li>
23. * <li>Generating a JWT token for authentication 
and authorization purposes.</li>
24. * </ul>
25. * </p>
26. *
27. * @param request A {@link RegisterRequest} containing 
the user's name, surname, email, phone, password, birthday, gender, 
and desired role.
28. * @return An {@link AuthenticationResponse} containing 
the JWT token for the newly registered user.
29. */
30. public AuthenticationResponse register(RegisterRequest 
request) {
31. var user = User.builder()
32. .name(request.getName())
33. .surname(request.getSurname())
34. .email(request.getEmail())
35. .phone(request.getPhone())
36. 
.password(passwordEncoder.encode(request.getPassword()))
37. .birthday(request.getBirthday())
38. .gender(request.getGender())
39. 
.creationDate(LocalDateTime.now().atZone(ZoneOffset.UTC))
40. .role(Role.USER)
41. .build();
42. 
43. userRepository.save(user);
44. 
45. var jwtTokent = jwtService.generateToken(user);
46. return AuthenticationResponse.builder()
47. .token(jwtTokent)
48. .build();
49. }
50. 
51. /**
52. * Authenticates a user based on their email and 
password. If authentication succeeds, a JWT token is issued.
53. * This method checks the user's credentials against 
the stored details in the database. If the credentials are valid,
54. * it generates a JWT token for the user, which can be 
used for further authentication and authorization tasks.
55. *
56. * <p>Key operations include:
57. * <ul>
58. * <li>Authenticating the user credentials using 
the authentication manager.</li>
59. * <li>Retrieving the user entity from the repository 
based on the email provided.</li>
69
60. * <li>Generating a JWT token for the authenticated 
user.</li>
61. * </ul>
62. * </p>
63. *
64. * @param request A {@link AuthenticationRequest} 
containing the user's email and password.
65. * @return An {@link AuthenticationResponse} containing 
the JWT token.
66. * @throws UsernameNotFoundException If no user is found 
with the provided email, indicating authentication failure.
67. */
68. public AuthenticationResponse 
authenticate(AuthenticationRequest request) {
69. authenticationManager.authenticate(
70. new UsernamePasswordAuthenticationToken(
71. request.getEmail(),
72. request.getPassword()
73. )
74. );
75. 
76. var user = 
userRepository.findByEmail(request.getEmail())
77. .orElseThrow(() -> new 
UsernameNotFoundException(request.getEmail()));
78. var jwtToken = jwtService.generateToken(user);
79. return AuthenticationResponse.builder()
80. .token(jwtToken)
81. .build();
82. }
83. 
84. /**
85. * Checks if the user associated with the provided JWT 
token has administrative privileges.
86. * This method extracts the username from the token, 
retrieves the corresponding user from the database,
87. * and then checks if the user has an administrator 
role.
88. *
89. * <p>Key operations include:
90. * <ul>
91. * <li>Extracting the username from the JWT 
token.</li>
92. * <li>Finding the user in the repository based on 
the extracted username.</li>
93. * <li>Checking if the user has administrative 
privileges using the JWT service.</li>
94. * </ul>
95. * </p>
96. *
97. * @param token The JWT token used to identify the user.
98. * @return A Boolean indicating whether the user is an 
administrator ({@code true}) or not ({@code false}).
70
99. * @throws UsernameNotFoundException If no user 
corresponds to the username extracted from the token or if there are 
other issues identified by an exception message.
100. */
101. public Boolean isAdmin(String token) {
102. try{
103. String username = 
jwtService.extractUsername(token);
104. Optional<User> optionalUser = 
userRepository.findByEmail(username);
105. if(optionalUser.isEmpty()) {
106. throw new UsernameNotFoundException("User 
not found");
107. }
108. 
109. User user = optionalUser.get();
110. return jwtService.isAdmin(token, user);
111. 
112. }catch (Exception e){
113. throw new UsernameNotFoundException("Something 
wrong: " + e.getMessage());
114. }
115. }
116. 
117. /**
118. * Determines if the user associated with the provided 
JWT token is recognized as a standard user in the system.
119. * This method extracts the username from the JWT, 
finds the corresponding user in the database, and assesses their 
user role.
120. *
121. * <p>Key operations include:
122. * <ul>
123. * <li>Extracting the username from the JWT token 
using the JWT service.</li>
124. * <li>Searching the user repository for a user 
with the extracted email.</li>
125. * <li>Verifying if the identified user matches 
the standard user criteria set within the JWT service.</li>
126. * </ul>
127. * </p>
128. *
129. * @param token The JWT token that is analyzed to 
identify the user.
130. * @return A Boolean indicating whether the user has 
standard user privileges ({@code true}) or not ({@code false}).
131. * @throws UsernameNotFoundException If no user 
corresponds to the username extracted from the token, or if other 
issues are identified through exception messages.
132. */
133. public Boolean isUser(String token) {
134. try{
71
135. String username = 
jwtService.extractUsername(token);
136. Optional<User> optionalUser = 
userRepository.findByEmail(username);
137. if(optionalUser.isEmpty()) {
138. throw new UsernameNotFoundException("User 
not found");
139. }
140. 
141. User user = optionalUser.get();
142. return jwtService.isUser(token, user);
143. 
144. }catch (Exception e){
145. throw new UsernameNotFoundException("Something 
wrong: " + e.getMessage());
146. }
147. }
148. 
149. /**
150. * Verifies the validity of a JWT token by ensuring it 
is correctly associated with a valid user and has not expired or 
been tampered with.
151. * This method extracts the username encoded within 
the token, looks up the corresponding user in the database, and then 
checks if the token remains valid with respect to the found user.
152. *
153. * <p>Key operations include:
154. * <ul>
155. * <li>Extracting the username from the JWT token 
using the JWT service.</li>
156. * <li>Finding the user in the database based on 
the extracted email.</li>
157. * <li>Validating the token against the user's 
details to ensure it has not expired or been compromised.</li>
158. * </ul>
159. * </p>
160. *
161. * @param token The JWT token to be validated.
162. * @return A Boolean indicating the validity of the 
token: {@code true} if the token is valid, {@code false} otherwise.
163. * @throws UsernameNotFoundException If no user 
corresponds to the username extracted from the token, indicating 
that the token is potentially invalid or forged.
164. */
165. public Boolean isValid(String token) {
166. String username = jwtService.extractUsername(token);
167. Optional<User> optionalUser = 
userRepository.findByEmail(username);
168. if(optionalUser.isEmpty()) {
169. throw new UsernameNotFoundException("User not 
found");
170. }
171. 
72
172. User user = optionalUser.get();
173. 
174. return jwtService.isTokenValid(token, user);
175. }
176. }
Код алгоритму пошуку «А*»:
1. public List<Point> sendVehicle(String number, String 
authHeader) {
2. if (!isAdmin(authHeader)) {
3. throw new IllegalStateException("Invalid auth 
header");
4. }
5. 
6. Optional<Vehicle> optionalVehicle = 
vehicleRepository.findByNumber(number);
7. if (optionalVehicle.isEmpty()) {
8. throw new IllegalStateException("Vehicle with 
number: " + number + " does not exist");
9. }
10. 
11. Vehicle vehicle = optionalVehicle.get();
12. String token = authHeader.substring(7);
13. 
14. HttpHeaders headers = new HttpHeaders();
15. headers.set("Authorization", "Bearer " + token);
16. HttpEntity<Void> orderHttpEntity = new 
HttpEntity<>(headers);
17. 
18. String urlToOrderService = 
orderServiceUrl.concat("/get-order-for-vehicle?droneId=" + 
vehicle.getId());
19. Order order = new Order();
20. try {
21. RestTemplate restTemplate = 
restTemplateBuilder.build();
22. ResponseEntity<Order> responseEntity = 
restTemplate.exchange(
23. urlToOrderService,
24. HttpMethod.GET,
25. orderHttpEntity,
26. Order.class
27. );
28. 
29. if 
(responseEntity.getStatusCode().is2xxSuccessful()) {
30. order = responseEntity.getBody();
31. if (!Order.orderHasDetails(order)) {
73
32. throw new IllegalStateException("Cannot 
send drone: " + number + "because wrong order");
33. }
34. }
35. } catch (Exception e) {
36. throw new RuntimeException(e);
37. }
38. 
39. Station deptStation = vehicle.getStation();
40. 
41. Optional<Station> optionalStation = 
stationRepository.findByNumber(order.getArrivalStationNumber());
42. if (optionalStation.isEmpty()) {
43. throw new IllegalStateException("Station with 
number: " + order.getArrivalStationNumber() + " does not exist");
44. }
45. 
46. Station arvlStation = optionalStation.get();
47. 
48. Double startLat, startLon, endLat, endLon;
49. startLat = deptStation.getLatitude();
50. startLon = deptStation.getLongitude();
51. endLat = arvlStation.getLatitude();
52. endLon = arvlStation.getLongitude();
53. 
54. double minLat = Math.min(startLat, endLat) -
BUFFER_RADIUS;
55. double maxLat = Math.max(startLat, endLat) + 
BUFFER_RADIUS;
56. double minLon = Math.min(startLon, endLon) -
BUFFER_RADIUS;
57. double maxLon = Math.max(startLon, endLon) + 
BUFFER_RADIUS;
58. 
59. Set<Point> crossings;
60. try {
61. crossings = 
loadCrossingsFromOpenStreetMap(minLat, minLon, maxLat, maxLon);
62. } catch (Exception e) {
63. throw new RuntimeException(e);
64. }
65. 
66. Point start = new Point(startLat, startLon);
67. Point end = new Point(endLat, endLon);
68. 
69. //TODO додати запит на конкретний дрон для 
завантаження шляху
70. return findShortestPath(start, end, crossings);
71. }
72. private Set<Point> clusterPoints(Set<Coordinate> 
coordinates) {
73. List<DoublePoint> doublePoints = new ArrayList<>();
74. for (Coordinate coordinate : coordinates) {
74
75. doublePoints.add(new DoublePoint(new 
double[]{coordinate.y, coordinate.x}));
76. }
77. 
78. DBSCANClusterer<DoublePoint> clusterer = new 
DBSCANClusterer<>(EPS, MIN_POINTS);
79. List<Cluster<DoublePoint>> clusters = 
clusterer.cluster(doublePoints);
80. 
81. Set<Point> clusteredPoints = new HashSet<>();
82. Set<DoublePoint> clusteredDoublePoints = new 
HashSet<>();
83. 
84. for (Cluster<DoublePoint> cluster : clusters) {
85. double sumLat = 0, sumLon = 0;
86. for (DoublePoint doublePoint : 
cluster.getPoints()) {
87. double[] values = doublePoint.getPoint();
88. sumLat += values[0];
89. sumLon += values[1];
90. clusteredDoublePoints.add(doublePoint);
91. }
92. double meanLat = sumLat / 
cluster.getPoints().size();
93. double meanLon = sumLon / 
cluster.getPoints().size();
94. clusteredPoints.add(new Point(meanLat, meanLon));
95. }
96. 
97. for (DoublePoint doublePoint : doublePoints) {
98. if (!clusteredDoublePoints.contains(doublePoint)) 
{
99. double[] values = doublePoint.getPoint();
100. clusteredPoints.add(new Point(values[0], 
values[1]));
101. }
102. }
103. 
104. return clusteredPoints;
105. }
106. public Set<Point> loadCrossingsFromOpenStreetMap(double 
minLat, double minLon, double maxLat, double maxLon) throws 
Exception {
107. String url = "https://overpassapi.de/api/interpreter";
108. String data = "[out:json];" +
109. "(node[\"highway\"=\"crossing\"](" + minLat 
+ "," + minLon + "," + maxLat + "," + maxLon + ");" +
110. "node[\"highway\"=\"turning_circle\"](" + 
minLat + "," + minLon + "," + maxLat + "," + maxLon + "););" +
111. "out;";
112. String fullUrl = url + "?data=" + data;
113. 
75
114. RestTemplate restTemplate = new RestTemplate();
115. ResponseEntity<String> response = 
restTemplate.getForEntity(fullUrl, String.class);
116. 
117. Set<Coordinate> crossings = new HashSet<>();
118. 
119. if (response.getStatusCode().is2xxSuccessful()) {
120. String responseBody = response.getBody();
121. ObjectMapper mapper = new ObjectMapper();
122. JsonNode root = mapper.readTree(responseBody);
123. JsonNode elements = root.path("elements");
124. 
125. for (JsonNode element : elements) {
126. double lat = element.get("lat").asDouble();
127. double lon = element.get("lon").asDouble();
128. crossings.add(new Coordinate(lon, lat));
129. }
130. } else {
131. throw new RuntimeException("Failed to fetch 
crossings data");
132. }
133. 
134. Set<Point> clusteredCrossings = 
clusterPoints(crossings);
135. 
136. return clusteredCrossings;
137. }
138. private List<Point> findShortestPath(Point start, Point 
end, Set<Point> crossings) {
139. PriorityQueue<Point> openSet = new 
PriorityQueue<>((a, b) -> {
140. double distA = distance(a, end);
141. double distB = distance(b, end);
142. return Double.compare(distA, distB);
143. });
144. openSet.offer(start);
145. Set<Point> closedSet = new HashSet<>();
146. Map<Point, Point> cameFrom = new HashMap<>();
147. Map<Point, Double> gScore = new HashMap<>();
148. 
149. gScore.put(start, 0.0);
150. 
151. crossings.add(end);
152. while (!openSet.isEmpty()) {
153. Point current = openSet.poll();
154. if (current.equals(end)) {
155. return reconstructPath(cameFrom, current);
156. }
157. closedSet.add(current);
158. for (Point neighbor : getNeighbors(current, 
crossings)) {
159. if (closedSet.contains(neighbor)) {
160. continue;
76
161. }
162. double tentativeScore = 
gScore.getOrDefault(current, Double.MAX_VALUE) + distance(current, 
neighbor);
163. if (!gScore.containsKey(neighbor) || 
tentativeScore < gScore.get(neighbor)) {
164. cameFrom.put(neighbor, current);
165. gScore.put(neighbor, tentativeScore);
166. openSet.offer(neighbor);
167. }
168. }
169. }
170. return Collections.emptyList();
171. }
172. private List<Point> getNeighbors(Point point, Set<Point> 
crossings) {
173. List<Point> neighbors = new ArrayList<>();
174. for (Point crossing : crossings) {
175. double dist = distance(point, crossing);
176. if (!crossing.equals(point) && dist < 
MIN_NEIGHBOUR_DISTANCE) {
177. neighbors.add(crossing);
178. }
179. }
180. return neighbors;
181. }
182. 
183. private List<Point> reconstructPath(Map<Point, Point> 
cameFrom, Point current) {
184. List<Point> path = new ArrayList<>();
185. path.add(current);
186. while (cameFrom.containsKey(current)) {
187. current = cameFrom.get(current);
188. path.add(current);
189. }
190. Collections.reverse(path);
191. return path;
192. }
193. private double distance(Point p1, Point p2) {
194. double lat1 = Math.toRadians(p1.getLatitude());
195. double lon1 = Math.toRadians(p1.getLongitude());
196. double lat2 = Math.toRadians(p2.getLatitude());
197. double lon2 = Math.toRadians(p2.getLongitude());
198. 
199. double dlon = lon2 - lon1;
200. double dlat = lat2 - lat1;
201. double a = Math.pow(Math.sin(dlat / 2), 2)
202. + Math.cos(lat1) * Math.cos(lat2)
203. * Math.pow(Math.sin(dlon / 2), 2);
204. 
205. double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 
- a));
206. double r = 6371; // Радіус Землі в кілометрах
77
207. return c * r;
208. }
209. 
210. private double distance(double lat1, double lon1, 
double lat2, double lon2) {
211. lat1 = Math.toRadians(lat1);
212. lon1 = Math.toRadians(lon1);
213. lat2 = Math.toRadians(lat2);
214. lon2 = Math.toRadians(lon2);
215. 
216. double dlon = lon2 - lon1;
217. double dlat = lat2 - lat1;
218. 
219. double a = Math.pow(Math.sin(dlat / 2), 2)
220. + Math.cos(lat1) * Math.cos(lat2)
221. * Math.pow(Math.sin(dlon / 2), 2);
222. double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 
- a));
223. double r = 6371;
224. 
225. return c * r;
226. }
Код сторінки Orders.tsx:
1. interface Order {
2. id: string;
3. userEmail: string;
4. vehicleNumber: string;
5. departureStationNumber: string;
6. arrivalStationNumber: string;
7. number: string;
8. receiptCode: string;
9. creationDate: string;
10. status: string;
11. items: { name: string; description: string; quantity: 
number; weight: number; isFragile: boolean }[];
12. }
13. 
14. interface AdaptedOrder {
15. id: string;
16. userEmail: string;
17. vehicleNumber: string;
18. departureStationNumber: string;
19. arrivalStationNumber: string;
20. number: string;
21. receiptCode: string;
22. creationDate: string;
23. status: string;
24. itemCount: number;
78
25. }
26. 
27. const tableHeader: string[] = [
28. 'Id',
29. 'User Email',
30. 'Vehicle Number',
31. 'Departure Station',
32. 'Arrival Station',
33. 'Order Number',
34. 'Receipt Code',
35. 'Creation Date',
36. 'Status',
37. 'Item Count',
38. 'Action'
39. ];
40. 
41. const Orders: React.FC = () => {
42. const [orders, setOrders] = useState<Order[]>([]);
43. const authContext = useContext(AuthContext);
44. const navigate = useNavigate();
45. 
46. useEffect(() => {
47. const loadData = async () => {
48. if (authContext?.isAuthenticated && 
authContext.token) {
49. try {
50. const fetchedOrders = await 
fetchOrders(authContext.token);
51. setOrders(fetchedOrders);
52. } catch (error) {
53. console.error('Error fetching orders:', 
error);
54. }
55. }
56. };
57. loadData();
58. }, [authContext?.isAuthenticated, authContext?.token]);
59. 
60. console.log(orders)
61. const adaptedOrders = orders.map(order => ({
62. id: order.id,
63. userEmail: order.userEmail,
64. vehicleNumber: order.vehicleNumber,
65. departureStationNumber: 
order.departureStationNumber,
66. arrivalStationNumber: order.arrivalStationNumber,
67. number: order.number,
68. receiptCode: order.receiptCode,
69. creationDate: order.creationDate,
70. status: order.status,
71. itemCount: order.items ? order.items.length : 0
72. }));
73. 
79
74. return (
75. <>
76. <h1>Orders</h1>
77. <DataTable
78. tableHeader={tableHeader}
79. tableRows={adaptedOrders}
80. tableButton={{
81. buttonAction: (rowData) => {
82. const order = orders.find(o => o.id 
=== rowData.id);
83. 
navigate(`/orders/process/${rowData.id}`, {state: {order}});
84. },
85. buttonLabel: 'Change'
86. }}
87. />
88. </>
89. );
90. };
91. 
92. export default Orders